.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "d2i_X509 3"
.TH d2i_X509 3 2016-05-03 1.0.2h OpenSSL
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
d2i_X509, i2d_X509, d2i_X509_bio, d2i_X509_fp, i2d_X509_bio,
i2d_X509_fp \- X509 encode and decode functions
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/x509.h>
\&
\& X509 *d2i_X509(X509 **px, const unsigned char **in, int len);
\& int i2d_X509(X509 *x, unsigned char **out);
\&
\& X509 *d2i_X509_bio(BIO *bp, X509 **x);
\& X509 *d2i_X509_fp(FILE *fp, X509 **x);
\&
\& int i2d_X509_bio(BIO *bp, X509 *x);
\& int i2d_X509_fp(FILE *fp, X509 *x);
\&
\& int i2d_re_X509_tbs(X509 *x, unsigned char **out);
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
The X509 encode and decode routines encode and parse an
\&\fBX509\fR structure, which represents an X509 certificate.
.PP
\&\fBd2i_X509()\fR attempts to decode \fBlen\fR bytes at \fB*in\fR. If 
successful a pointer to the \fBX509\fR structure is returned. If an error
occurred then \fBNULL\fR is returned. If \fBpx\fR is not \fBNULL\fR then the
returned structure is written to \fB*px\fR. If \fB*px\fR is not \fBNULL\fR
then it is assumed that \fB*px\fR contains a valid \fBX509\fR
structure and an attempt is made to reuse it. This "reuse" capability is present
for historical compatibility but its use is \fBstrongly discouraged\fR (see BUGS
below, and the discussion in the RETURN VALUES section).
.PP
If the call is successful \fB*in\fR is incremented to the byte following the
parsed data.
.PP
\&\fBi2d_X509()\fR encodes the structure pointed to by \fBx\fR into DER format.
If \fBout\fR is not \fBNULL\fR is writes the DER encoded data to the buffer
at \fB*out\fR, and increments it to point after the data just written.
If the return value is negative an error occurred, otherwise it
returns the length of the encoded data.
.PP
For OpenSSL 0.9.7 and later if \fB*out\fR is \fBNULL\fR memory will be
allocated for a buffer and the encoded data written to it. In this
case \fB*out\fR is not incremented and it points to the start of the
data just written.
.PP
\&\fBd2i_X509_bio()\fR is similar to \fBd2i_X509()\fR except it attempts
to parse data from BIO \fBbp\fR.
.PP
\&\fBd2i_X509_fp()\fR is similar to \fBd2i_X509()\fR except it attempts
to parse data from FILE pointer \fBfp\fR.
.PP
\&\fBi2d_X509_bio()\fR is similar to \fBi2d_X509()\fR except it writes
the encoding of the structure \fBx\fR to BIO \fBbp\fR and it
returns 1 for success and 0 for failure.
.PP
\&\fBi2d_X509_fp()\fR is similar to \fBi2d_X509()\fR except it writes
the encoding of the structure \fBx\fR to BIO \fBbp\fR and it
returns 1 for success and 0 for failure.
.PP
\&\fBi2d_re_X509_tbs()\fR is similar to \fBi2d_X509()\fR except it encodes
only the TBSCertificate portion of the certificate.
.SH NOTES
.IX Header "NOTES"
The letters \fBi\fR and \fBd\fR in for example \fBi2d_X509\fR stand for
"internal" (that is an internal C structure) and "DER". So
\&\fBi2d_X509\fR converts from internal to DER. The "re" in
\&\fBi2d_re_X509_tbs\fR stands for "re-encode", and ensures that a fresh
encoding is generated in case the object has been modified after
creation (see the BUGS section).
.PP
The functions can also understand \fBBER\fR forms.
.PP
The actual X509 structure passed to \fBi2d_X509()\fR must be a valid
populated \fBX509\fR structure it can \fBnot\fR simply be fed with an
empty structure such as that returned by \fBX509_new()\fR.
.PP
The encoded data is in binary form and may contain embedded zeroes.
Therefore any FILE pointers or BIOs should be opened in binary mode.
Functions such as \fBstrlen()\fR will \fBnot\fR return the correct length
of the encoded structure.
.PP
The ways that \fB*in\fR and \fB*out\fR are incremented after the operation
can trap the unwary. See the \fBWARNINGS\fR section for some common
errors.
.PP
The reason for the auto increment behaviour is to reflect a typical
usage of ASN1 functions: after one structure is encoded or decoded
another will processed after it.
.SH EXAMPLES
.IX Header "EXAMPLES"
Allocate and encode the DER encoding of an X509 structure:
.PP
.Vb 2
\& int len;
\& unsigned char *buf, *p;
\&
\& len = i2d_X509(x, NULL);
\&
\& buf = OPENSSL_malloc(len);
\&
\& if (buf == NULL)
\&        /* error */
\&
\& p = buf;
\&
\& i2d_X509(x, &p);
.Ve
.PP
If you are using OpenSSL 0.9.7 or later then this can be
simplified to:
.PP
.Vb 2
\& int len;
\& unsigned char *buf;
\&
\& buf = NULL;
\&
\& len = i2d_X509(x, &buf);
\&
\& if (len < 0)
\&        /* error */
.Ve
.PP
Attempt to decode a buffer:
.PP
.Vb 1
\& X509 *x;
\&
\& unsigned char *buf, *p;
\&
\& int len;
\&
\& /* Something to setup buf and len */
\&
\& p = buf;
\&
\& x = d2i_X509(NULL, &p, len);
\&
\& if (x == NULL)
\&    /* Some error */
.Ve
.PP
Alternative technique:
.PP
.Vb 1
\& X509 *x;
\&
\& unsigned char *buf, *p;
\&
\& int len;
\&
\& /* Something to setup buf and len */
\&
\& p = buf;
\&
\& x = NULL;
\&
\& if(!d2i_X509(&x, &p, len))
\&    /* Some error */
.Ve
.SH WARNINGS
.IX Header "WARNINGS"
The use of temporary variable is mandatory. A common
mistake is to attempt to use a buffer directly as follows:
.PP
.Vb 2
\& int len;
\& unsigned char *buf;
\&
\& len = i2d_X509(x, NULL);
\&
\& buf = OPENSSL_malloc(len);
\&
\& if (buf == NULL)
\&        /* error */
\&
\& i2d_X509(x, &buf);
\&
\& /* Other stuff ... */
\&
\& OPENSSL_free(buf);
.Ve
.PP
This code will result in \fBbuf\fR apparently containing garbage because
it was incremented after the call to point after the data just written.
Also \fBbuf\fR will no longer contain the pointer allocated by \fBOPENSSL_malloc()\fR
and the subsequent call to \fBOPENSSL_free()\fR may well crash.
.PP
The auto allocation feature (setting buf to NULL) only works on OpenSSL
0.9.7 and later. Attempts to use it on earlier versions will typically
cause a segmentation violation.
.PP
Another trap to avoid is misuse of the \fBxp\fR argument to \fBd2i_X509()\fR:
.PP
.Vb 1
\& X509 *x;
\&
\& if (!d2i_X509(&x, &p, len))
\&        /* Some error */
.Ve
.PP
This will probably crash somewhere in \fBd2i_X509()\fR. The reason for this
is that the variable \fBx\fR is uninitialized and an attempt will be made to
interpret its (invalid) value as an \fBX509\fR structure, typically causing
a segmentation violation. If \fBx\fR is set to NULL first then this will not
happen.
.SH BUGS
.IX Header "BUGS"
In some versions of OpenSSL the "reuse" behaviour of \fBd2i_X509()\fR when 
\&\fB*px\fR is valid is broken and some parts of the reused structure may
persist if they are not present in the new one. As a result the use
of this "reuse" behaviour is strongly discouraged.
.PP
\&\fBi2d_X509()\fR will not return an error in many versions of OpenSSL,
if mandatory fields are not initialized due to a programming error
then the encoded structure may contain invalid data or omit the
fields entirely and will not be parsed by \fBd2i_X509()\fR. This may be
fixed in future so code should not assume that \fBi2d_X509()\fR will
always succeed.
.PP
The encoding of the TBSCertificate portion of a certificate is cached
in the \fBX509\fR structure internally to improve encoding performance
and to ensure certificate signatures are verified correctly in some
certificates with broken (non-DER) encodings.
.PP
Any function which encodes an X509 structure such as \fBi2d_X509()\fR,
\&\fBi2d_X509_fp()\fR or \fBi2d_X509_bio()\fR may return a stale encoding if the
\&\fBX509\fR structure has been modified after deserialization or previous
serialization.
.PP
If, after modification, the \fBX509\fR object is re-signed with \fBX509_sign()\fR,
the encoding is automatically renewed. Otherwise, the encoding of the
TBSCertificate portion of the \fBX509\fR can be manually renewed by calling
\&\fBi2d_re_X509_tbs()\fR.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fBd2i_X509()\fR, \fBd2i_X509_bio()\fR and \fBd2i_X509_fp()\fR return a valid \fBX509\fR structure
or \fBNULL\fR if an error occurs. The error code that can be obtained by
\&\fBERR_get_error\fR\|(3). If the "reuse" capability has been used
with a valid X509 structure being passed in via \fBpx\fR then the object is not
freed in the event of error but may be in a potentially invalid or inconsistent
state.
.PP
\&\fBi2d_X509()\fR returns the number of bytes successfully encoded or a negative
value if an error occurs. The error code can be obtained by
\&\fBERR_get_error\fR\|(3).
.PP
\&\fBi2d_X509_bio()\fR and \fBi2d_X509_fp()\fR return 1 for success and 0 if an error 
occurs The error code can be obtained by \fBERR_get_error\fR\|(3).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBERR_get_error\fR\|(3)
.SH HISTORY
.IX Header "HISTORY"
d2i_X509, i2d_X509, d2i_X509_bio, d2i_X509_fp, i2d_X509_bio and i2d_X509_fp
are available in all versions of SSLeay and OpenSSL.
