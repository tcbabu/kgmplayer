.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "BIO_s_mem 3"
.TH BIO_s_mem 3 2016-05-03 1.0.2h OpenSSL
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
BIO_s_mem, BIO_set_mem_eof_return, BIO_get_mem_data, BIO_set_mem_buf,
BIO_get_mem_ptr, BIO_new_mem_buf \- memory BIO
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/bio.h>
\&
\& BIO_METHOD *   BIO_s_mem(void);
\&
\& BIO_set_mem_eof_return(BIO *b,int v)
\& long BIO_get_mem_data(BIO *b, char **pp)
\& BIO_set_mem_buf(BIO *b,BUF_MEM *bm,int c)
\& BIO_get_mem_ptr(BIO *b,BUF_MEM **pp)
\&
\& BIO *BIO_new_mem_buf(const void *buf, int len);
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
\&\fBBIO_s_mem()\fR return the memory BIO method function.
.PP
A memory BIO is a source/sink BIO which uses memory for its I/O. Data
written to a memory BIO is stored in a BUF_MEM structure which is extended
as appropriate to accommodate the stored data.
.PP
Any data written to a memory BIO can be recalled by reading from it.
Unless the memory BIO is read only any data read from it is deleted from
the BIO.
.PP
Memory BIOs support \fBBIO_gets()\fR and \fBBIO_puts()\fR.
.PP
If the BIO_CLOSE flag is set when a memory BIO is freed then the underlying
BUF_MEM structure is also freed.
.PP
Calling \fBBIO_reset()\fR on a read write memory BIO clears any data in it. On a
read only BIO it restores the BIO to its original state and the read only
data can be read again.
.PP
\&\fBBIO_eof()\fR is true if no data is in the BIO.
.PP
\&\fBBIO_ctrl_pending()\fR returns the number of bytes currently stored.
.PP
\&\fBBIO_set_mem_eof_return()\fR sets the behaviour of memory BIO \fBb\fR when it is
empty. If the \fBv\fR is zero then an empty memory BIO will return EOF (that is
it will return zero and BIO_should_retry(b) will be false. If \fBv\fR is non
zero then it will return \fBv\fR when it is empty and it will set the read retry
flag (that is BIO_read_retry(b) is true). To avoid ambiguity with a normal
positive return value \fBv\fR should be set to a negative value, typically \-1.
.PP
\&\fBBIO_get_mem_data()\fR sets \fBpp\fR to a pointer to the start of the memory BIOs data
and returns the total amount of data available. It is implemented as a macro.
.PP
\&\fBBIO_set_mem_buf()\fR sets the internal BUF_MEM structure to \fBbm\fR and sets the
close flag to \fBc\fR, that is \fBc\fR should be either BIO_CLOSE or BIO_NOCLOSE.
It is a macro.
.PP
\&\fBBIO_get_mem_ptr()\fR places the underlying BUF_MEM structure in \fBpp\fR. It is
a macro.
.PP
\&\fBBIO_new_mem_buf()\fR creates a memory BIO using \fBlen\fR bytes of data at \fBbuf\fR,
if \fBlen\fR is \-1 then the \fBbuf\fR is assumed to be nul terminated and its
length is determined by \fBstrlen\fR. The BIO is set to a read only state and
as a result cannot be written to. This is useful when some data needs to be
made available from a static area of memory in the form of a BIO. The
supplied data is read directly from the supplied buffer: it is \fBnot\fR copied
first, so the supplied area of memory must be unchanged until the BIO is freed.
.SH NOTES
.IX Header "NOTES"
Writes to memory BIOs will always succeed if memory is available: that is
their size can grow indefinitely.
.PP
Every read from a read write memory BIO will remove the data just read with
an internal copy operation, if a BIO contains a lot of data and it is
read in small chunks the operation can be very slow. The use of a read only
memory BIO avoids this problem. If the BIO must be read write then adding
a buffering BIO to the chain will speed up the process.
.SH BUGS
.IX Header "BUGS"
There should be an option to set the maximum size of a memory BIO.
.PP
There should be a way to "rewind" a read write BIO without destroying
its contents.
.PP
The copying operation should not occur after every small read of a large BIO
to improve efficiency.
.SH EXAMPLE
.IX Header "EXAMPLE"
Create a memory BIO and write some data to it:
.PP
.Vb 2
\& BIO *mem = BIO_new(BIO_s_mem());
\& BIO_puts(mem, "Hello World\en");
.Ve
.PP
Create a read only memory BIO:
.PP
.Vb 3
\& char data[] = "Hello World";
\& BIO *mem;
\& mem = BIO_new_mem_buf(data, \-1);
.Ve
.PP
Extract the BUF_MEM structure from a memory BIO and then free up the BIO:
.PP
.Vb 4
\& BUF_MEM *bptr;
\& BIO_get_mem_ptr(mem, &bptr);
\& BIO_set_close(mem, BIO_NOCLOSE); /* So BIO_free() leaves BUF_MEM alone */
\& BIO_free(mem);
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
TBA
