.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "bn_internal 3"
.TH bn_internal 3 2016-05-03 1.0.2h OpenSSL
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
bn_mul_words, bn_mul_add_words, bn_sqr_words, bn_div_words,
bn_add_words, bn_sub_words, bn_mul_comba4, bn_mul_comba8,
bn_sqr_comba4, bn_sqr_comba8, bn_cmp_words, bn_mul_normal,
bn_mul_low_normal, bn_mul_recursive, bn_mul_part_recursive,
bn_mul_low_recursive, bn_mul_high, bn_sqr_normal, bn_sqr_recursive,
bn_expand, bn_wexpand, bn_expand2, bn_fix_top, bn_check_top,
bn_print, bn_dump, bn_set_max, bn_set_high, bn_set_low \- BIGNUM
library internal functions
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/bn.h>
\&
\& BN_ULONG bn_mul_words(BN_ULONG *rp, BN_ULONG *ap, int num, BN_ULONG w);
\& BN_ULONG bn_mul_add_words(BN_ULONG *rp, BN_ULONG *ap, int num,
\&   BN_ULONG w);
\& void     bn_sqr_words(BN_ULONG *rp, BN_ULONG *ap, int num);
\& BN_ULONG bn_div_words(BN_ULONG h, BN_ULONG l, BN_ULONG d);
\& BN_ULONG bn_add_words(BN_ULONG *rp, BN_ULONG *ap, BN_ULONG *bp,
\&   int num);
\& BN_ULONG bn_sub_words(BN_ULONG *rp, BN_ULONG *ap, BN_ULONG *bp,
\&   int num);
\&
\& void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b);
\& void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b);
\& void bn_sqr_comba4(BN_ULONG *r, BN_ULONG *a);
\& void bn_sqr_comba8(BN_ULONG *r, BN_ULONG *a);
\&
\& int bn_cmp_words(BN_ULONG *a, BN_ULONG *b, int n);
\&
\& void bn_mul_normal(BN_ULONG *r, BN_ULONG *a, int na, BN_ULONG *b,
\&   int nb);
\& void bn_mul_low_normal(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n);
\& void bn_mul_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n2,
\&   int dna,int dnb,BN_ULONG *tmp);
\& void bn_mul_part_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b,
\&   int n, int tna,int tnb, BN_ULONG *tmp);
\& void bn_mul_low_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b,
\&   int n2, BN_ULONG *tmp);
\& void bn_mul_high(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, BN_ULONG *l,
\&   int n2, BN_ULONG *tmp);
\&
\& void bn_sqr_normal(BN_ULONG *r, BN_ULONG *a, int n, BN_ULONG *tmp);
\& void bn_sqr_recursive(BN_ULONG *r, BN_ULONG *a, int n2, BN_ULONG *tmp);
\&
\& void mul(BN_ULONG r, BN_ULONG a, BN_ULONG w, BN_ULONG c);
\& void mul_add(BN_ULONG r, BN_ULONG a, BN_ULONG w, BN_ULONG c);
\& void sqr(BN_ULONG r0, BN_ULONG r1, BN_ULONG a);
\&
\& BIGNUM *bn_expand(BIGNUM *a, int bits);
\& BIGNUM *bn_wexpand(BIGNUM *a, int n);
\& BIGNUM *bn_expand2(BIGNUM *a, int n);
\& void bn_fix_top(BIGNUM *a);
\&
\& void bn_check_top(BIGNUM *a);
\& void bn_print(BIGNUM *a);
\& void bn_dump(BN_ULONG *d, int n);
\& void bn_set_max(BIGNUM *a);
\& void bn_set_high(BIGNUM *r, BIGNUM *a, int n);
\& void bn_set_low(BIGNUM *r, BIGNUM *a, int n);
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This page documents the internal functions used by the OpenSSL
\&\fBBIGNUM\fR implementation. They are described here to facilitate
debugging and extending the library. They are \fInot\fR to be used by
applications.
.SS "The BIGNUM structure"
.IX Subsection "The BIGNUM structure"
.Vb 1
\& typedef struct bignum_st BIGNUM;
\&
\& struct bignum_st
\&        {
\&        BN_ULONG *d;    /* Pointer to an array of \*(AqBN_BITS2\*(Aq bit chunks. */
\&        int top;        /* Index of last used d +1. */
\&        /* The next are internal book keeping for bn_expand. */
\&        int dmax;       /* Size of the d array. */
\&        int neg;        /* one if the number is negative */
\&        int flags;
\&        };
.Ve
.PP
The integer value is stored in \fBd\fR, a \fBmalloc()\fRed array of words (\fBBN_ULONG\fR),
least significant word first. A \fBBN_ULONG\fR can be either 16, 32 or 64 bits
in size, depending on the 'number of bits' (\fBBITS2\fR) specified in
\&\f(CW\*(C`openssl/bn.h\*(C'\fR.
.PP
\&\fBdmax\fR is the size of the \fBd\fR array that has been allocated.  \fBtop\fR
is the number of words being used, so for a value of 4, bn.d[0]=4 and
bn.top=1.  \fBneg\fR is 1 if the number is negative.  When a \fBBIGNUM\fR is
\&\fB0\fR, the \fBd\fR field can be \fBNULL\fR and \fBtop\fR == \fB0\fR.
.PP
\&\fBflags\fR is a bit field of flags which are defined in \f(CW\*(C`openssl/bn.h\*(C'\fR. The 
flags begin with \fBBN_FLG_\fR. The macros BN_set_flags(b,n) and 
BN_get_flags(b,n) exist to enable or fetch flag(s) \fBn\fR from \fBBIGNUM\fR
structure \fBb\fR.
.PP
Various routines in this library require the use of temporary
\&\fBBIGNUM\fR variables during their execution.  Since dynamic memory
allocation to create \fBBIGNUM\fRs is rather expensive when used in
conjunction with repeated subroutine calls, the \fBBN_CTX\fR structure is
used.  This structure contains \fBBN_CTX_NUM\fR \fBBIGNUM\fRs, see
\&\fBBN_CTX_start\fR\|(3).
.SS "Low-level arithmetic operations"
.IX Subsection "Low-level arithmetic operations"
These functions are implemented in C and for several platforms in
assembly language:
.PP
bn_mul_words(\fBrp\fR, \fBap\fR, \fBnum\fR, \fBw\fR) operates on the \fBnum\fR word
arrays \fBrp\fR and \fBap\fR.  It computes \fBap\fR * \fBw\fR, places the result
in \fBrp\fR, and returns the high word (carry).
.PP
bn_mul_add_words(\fBrp\fR, \fBap\fR, \fBnum\fR, \fBw\fR) operates on the \fBnum\fR
word arrays \fBrp\fR and \fBap\fR.  It computes \fBap\fR * \fBw\fR + \fBrp\fR, places
the result in \fBrp\fR, and returns the high word (carry).
.PP
bn_sqr_words(\fBrp\fR, \fBap\fR, \fBn\fR) operates on the \fBnum\fR word array
\&\fBap\fR and the 2*\fBnum\fR word array \fBap\fR.  It computes \fBap\fR * \fBap\fR
word-wise, and places the low and high bytes of the result in \fBrp\fR.
.PP
bn_div_words(\fBh\fR, \fBl\fR, \fBd\fR) divides the two word number (\fBh\fR,\fBl\fR)
by \fBd\fR and returns the result.
.PP
bn_add_words(\fBrp\fR, \fBap\fR, \fBbp\fR, \fBnum\fR) operates on the \fBnum\fR word
arrays \fBap\fR, \fBbp\fR and \fBrp\fR.  It computes \fBap\fR + \fBbp\fR, places the
result in \fBrp\fR, and returns the high word (carry).
.PP
bn_sub_words(\fBrp\fR, \fBap\fR, \fBbp\fR, \fBnum\fR) operates on the \fBnum\fR word
arrays \fBap\fR, \fBbp\fR and \fBrp\fR.  It computes \fBap\fR \- \fBbp\fR, places the
result in \fBrp\fR, and returns the carry (1 if \fBbp\fR > \fBap\fR, 0
otherwise).
.PP
bn_mul_comba4(\fBr\fR, \fBa\fR, \fBb\fR) operates on the 4 word arrays \fBa\fR and
\&\fBb\fR and the 8 word array \fBr\fR.  It computes \fBa\fR*\fBb\fR and places the
result in \fBr\fR.
.PP
bn_mul_comba8(\fBr\fR, \fBa\fR, \fBb\fR) operates on the 8 word arrays \fBa\fR and
\&\fBb\fR and the 16 word array \fBr\fR.  It computes \fBa\fR*\fBb\fR and places the
result in \fBr\fR.
.PP
bn_sqr_comba4(\fBr\fR, \fBa\fR, \fBb\fR) operates on the 4 word arrays \fBa\fR and
\&\fBb\fR and the 8 word array \fBr\fR.
.PP
bn_sqr_comba8(\fBr\fR, \fBa\fR, \fBb\fR) operates on the 8 word arrays \fBa\fR and
\&\fBb\fR and the 16 word array \fBr\fR.
.PP
The following functions are implemented in C:
.PP
bn_cmp_words(\fBa\fR, \fBb\fR, \fBn\fR) operates on the \fBn\fR word arrays \fBa\fR
and \fBb\fR.  It returns 1, 0 and \-1 if \fBa\fR is greater than, equal and
less than \fBb\fR.
.PP
bn_mul_normal(\fBr\fR, \fBa\fR, \fBna\fR, \fBb\fR, \fBnb\fR) operates on the \fBna\fR
word array \fBa\fR, the \fBnb\fR word array \fBb\fR and the \fBna\fR+\fBnb\fR word
array \fBr\fR.  It computes \fBa\fR*\fBb\fR and places the result in \fBr\fR.
.PP
bn_mul_low_normal(\fBr\fR, \fBa\fR, \fBb\fR, \fBn\fR) operates on the \fBn\fR word
arrays \fBr\fR, \fBa\fR and \fBb\fR.  It computes the \fBn\fR low words of
\&\fBa\fR*\fBb\fR and places the result in \fBr\fR.
.PP
bn_mul_recursive(\fBr\fR, \fBa\fR, \fBb\fR, \fBn2\fR, \fBdna\fR, \fBdnb\fR, \fBt\fR) operates
on the word arrays \fBa\fR and \fBb\fR of length \fBn2\fR+\fBdna\fR and \fBn2\fR+\fBdnb\fR
(\fBdna\fR and \fBdnb\fR are currently allowed to be 0 or negative) and the 2*\fBn2\fR
word arrays \fBr\fR and \fBt\fR.  \fBn2\fR must be a power of 2.  It computes
\&\fBa\fR*\fBb\fR and places the result in \fBr\fR.
.PP
bn_mul_part_recursive(\fBr\fR, \fBa\fR, \fBb\fR, \fBn\fR, \fBtna\fR, \fBtnb\fR, \fBtmp\fR)
operates on the word arrays \fBa\fR and \fBb\fR of length \fBn\fR+\fBtna\fR and
\&\fBn\fR+\fBtnb\fR and the 4*\fBn\fR word arrays \fBr\fR and \fBtmp\fR.
.PP
bn_mul_low_recursive(\fBr\fR, \fBa\fR, \fBb\fR, \fBn2\fR, \fBtmp\fR) operates on the
\&\fBn2\fR word arrays \fBr\fR and \fBtmp\fR and the \fBn2\fR/2 word arrays \fBa\fR
and \fBb\fR.
.PP
bn_mul_high(\fBr\fR, \fBa\fR, \fBb\fR, \fBl\fR, \fBn2\fR, \fBtmp\fR) operates on the
\&\fBn2\fR word arrays \fBr\fR, \fBa\fR, \fBb\fR and \fBl\fR (?) and the 3*\fBn2\fR word
array \fBtmp\fR.
.PP
\&\fBBN_mul()\fR calls \fBbn_mul_normal()\fR, or an optimized implementation if the
factors have the same size: \fBbn_mul_comba8()\fR is used if they are 8
words long, \fBbn_mul_recursive()\fR if they are larger than
\&\fBBN_MULL_SIZE_NORMAL\fR and the size is an exact multiple of the word
size, and \fBbn_mul_part_recursive()\fR for others that are larger than
\&\fBBN_MULL_SIZE_NORMAL\fR.
.PP
bn_sqr_normal(\fBr\fR, \fBa\fR, \fBn\fR, \fBtmp\fR) operates on the \fBn\fR word array
\&\fBa\fR and the 2*\fBn\fR word arrays \fBtmp\fR and \fBr\fR.
.PP
The implementations use the following macros which, depending on the
architecture, may use "long long" C operations or inline assembler.
They are defined in \f(CW\*(C`bn_lcl.h\*(C'\fR.
.PP
mul(\fBr\fR, \fBa\fR, \fBw\fR, \fBc\fR) computes \fBw\fR*\fBa\fR+\fBc\fR and places the
low word of the result in \fBr\fR and the high word in \fBc\fR.
.PP
mul_add(\fBr\fR, \fBa\fR, \fBw\fR, \fBc\fR) computes \fBw\fR*\fBa\fR+\fBr\fR+\fBc\fR and
places the low word of the result in \fBr\fR and the high word in \fBc\fR.
.PP
sqr(\fBr0\fR, \fBr1\fR, \fBa\fR) computes \fBa\fR*\fBa\fR and places the low word
of the result in \fBr0\fR and the high word in \fBr1\fR.
.SS "Size changes"
.IX Subsection "Size changes"
\&\fBbn_expand()\fR ensures that \fBb\fR has enough space for a \fBbits\fR bit
number.  \fBbn_wexpand()\fR ensures that \fBb\fR has enough space for an
\&\fBn\fR word number.  If the number has to be expanded, both macros
call \fBbn_expand2()\fR, which allocates a new \fBd\fR array and copies the
data.  They return \fBNULL\fR on error, \fBb\fR otherwise.
.PP
The \fBbn_fix_top()\fR macro reduces \fBa\->top\fR to point to the most
significant non-zero word plus one when \fBa\fR has shrunk.
.SS Debugging
.IX Subsection "Debugging"
\&\fBbn_check_top()\fR verifies that \f(CW\*(C`((a)\->top >= 0 && (a)\->top
<= (a)\->dmax)\*(C'\fR.  A violation will cause the program to abort.
.PP
\&\fBbn_print()\fR prints \fBa\fR to stderr. \fBbn_dump()\fR prints \fBn\fR words at \fBd\fR
(in reverse order, i.e. most significant word first) to stderr.
.PP
\&\fBbn_set_max()\fR makes \fBa\fR a static number with a \fBdmax\fR of its current size.
This is used by \fBbn_set_low()\fR and \fBbn_set_high()\fR to make \fBr\fR a read-only
\&\fBBIGNUM\fR that contains the \fBn\fR low or high words of \fBa\fR.
.PP
If \fBBN_DEBUG\fR is not defined, \fBbn_check_top()\fR, \fBbn_print()\fR, \fBbn_dump()\fR
and \fBbn_set_max()\fR are defined as empty macros.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBbn\fR\|(3)
