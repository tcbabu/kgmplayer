.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "d2i_ECPKParameters 3"
.TH d2i_ECPKParameters 3 2016-05-03 1.0.2h OpenSSL
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
d2i_ECPKParameters, i2d_ECPKParameters, d2i_ECPKParameters_bio, i2d_ECPKParameters_bio, d2i_ECPKParameters_fp, i2d_ECPKParameters_fp, ECPKParameters_print, ECPKParameters_print_fp \- Functions for decoding and encoding ASN1 representations of elliptic curve entities
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/ec.h>
\&
\& EC_GROUP *d2i_ECPKParameters(EC_GROUP **px, const unsigned char **in, long len);
\& int i2d_ECPKParameters(const EC_GROUP *x, unsigned char **out);
\& #define d2i_ECPKParameters_bio(bp,x) ASN1_d2i_bio_of(EC_GROUP,NULL,d2i_ECPKParameters,bp,x)
\& #define i2d_ECPKParameters_bio(bp,x) ASN1_i2d_bio_of_const(EC_GROUP,i2d_ECPKParameters,bp,x)
\& #define d2i_ECPKParameters_fp(fp,x) (EC_GROUP *)ASN1_d2i_fp(NULL, \e
\&                (char *(*)())d2i_ECPKParameters,(fp),(unsigned char **)(x))
\& #define i2d_ECPKParameters_fp(fp,x) ASN1_i2d_fp(i2d_ECPKParameters,(fp), \e
\&                (unsigned char *)(x))
\& int     ECPKParameters_print(BIO *bp, const EC_GROUP *x, int off);
\& int     ECPKParameters_print_fp(FILE *fp, const EC_GROUP *x, int off);
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
The ECPKParameters encode and decode routines encode and parse the public parameters for an
\&\fBEC_GROUP\fR structure, which represents a curve.
.PP
\&\fBd2i_ECPKParameters()\fR attempts to decode \fBlen\fR bytes at \fB*in\fR. If 
successful a pointer to the \fBEC_GROUP\fR structure is returned. If an error
occurred then \fBNULL\fR is returned. If \fBpx\fR is not \fBNULL\fR then the
returned structure is written to \fB*px\fR. If \fB*px\fR is not \fBNULL\fR
then it is assumed that \fB*px\fR contains a valid \fBEC_GROUP\fR
structure and an attempt is made to reuse it. If the call is
successful \fB*in\fR is incremented to the byte following the
parsed data.
.PP
\&\fBi2d_ECPKParameters()\fR encodes the structure pointed to by \fBx\fR into DER format.
If \fBout\fR is not \fBNULL\fR is writes the DER encoded data to the buffer
at \fB*out\fR, and increments it to point after the data just written.
If the return value is negative an error occurred, otherwise it
returns the length of the encoded data.
.PP
If \fB*out\fR is \fBNULL\fR memory will be allocated for a buffer and the encoded
data written to it. In this case \fB*out\fR is not incremented and it points to
the start of the data just written.
.PP
\&\fBd2i_ECPKParameters_bio()\fR is similar to \fBd2i_ECPKParameters()\fR except it attempts
to parse data from BIO \fBbp\fR.
.PP
\&\fBd2i_ECPKParameters_fp()\fR is similar to \fBd2i_ECPKParameters()\fR except it attempts
to parse data from FILE pointer \fBfp\fR.
.PP
\&\fBi2d_ECPKParameters_bio()\fR is similar to \fBi2d_ECPKParameters()\fR except it writes
the encoding of the structure \fBx\fR to BIO \fBbp\fR and it
returns 1 for success and 0 for failure.
.PP
\&\fBi2d_ECPKParameters_fp()\fR is similar to \fBi2d_ECPKParameters()\fR except it writes
the encoding of the structure \fBx\fR to BIO \fBbp\fR and it
returns 1 for success and 0 for failure.
.PP
These functions are very similar to the X509 functions described in \fBd2i_X509\fR\|(3),
where further notes and examples are available.
.PP
The ECPKParameters_print and ECPKParameters_print_fp functions print a human-readable output
of the public parameters of the EC_GROUP to \fBbp\fR or \fBfp\fR. The output lines are indented by \fBoff\fR spaces.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fBd2i_ECPKParameters()\fR, \fBd2i_ECPKParameters_bio()\fR and \fBd2i_ECPKParameters_fp()\fR return a valid \fBEC_GROUP\fR structure
or \fBNULL\fR if an error occurs.
.PP
\&\fBi2d_ECPKParameters()\fR returns the number of bytes successfully encoded or a negative
value if an error occurs.
.PP
\&\fBi2d_ECPKParameters_bio()\fR, \fBi2d_ECPKParameters_fp()\fR, ECPKParameters_print and ECPKParameters_print_fp
return 1 for success and 0 if an error occurs.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBcrypto\fR\|(3), \fBec\fR\|(3), \fBEC_GROUP_new\fR\|(3), \fBEC_GROUP_copy\fR\|(3),
\&\fBEC_POINT_new\fR\|(3), \fBEC_POINT_add\fR\|(3), \fBEC_KEY_new\fR\|(3),
\&\fBEC_GFp_simple_method\fR\|(3), \fBd2i_X509\fR\|(3)
